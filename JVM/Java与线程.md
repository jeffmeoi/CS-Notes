<!-- TOC -->

- [Java与线程](#java与线程)
  - [线程的实现](#线程的实现)
    - [1. 使用内核线程实现](#1-使用内核线程实现)
      - [轻量级进程的优势](#轻量级进程的优势)
      - [轻量级进程的局限性](#轻量级进程的局限性)
    - [2. 使用用户线程实现](#2-使用用户线程实现)
      - [用户线程的优势](#用户线程的优势)
      - [用户线程的局限性](#用户线程的局限性)
    - [3. 使用用户线程加轻量级进程混合实现](#3-使用用户线程加轻量级进程混合实现)
    - [4. Java线程的实现](#4-java线程的实现)
  - [Java线程调度](#java线程调度)
      - [协同式调度](#协同式调度)
      - [抢占式调度](#抢占式调度)
  - [状态转换](#状态转换)
  - [Reference](#reference)

<!-- /TOC -->

# Java与线程

## 线程的实现

实现线程主要由3种方式：使用内核线程实现、使用用户线程实现、使用用户线程加轻量级进程混合实现；

### 1. 使用内核线程实现

内核线程(Kernel-Level Thread, **KLT**)就是**直接由操作系统内核(Kernel)支持的线程**，这种线程由内核来完成线程切换，内核通过操纵调度器(Scheduler)对线程进行调度，并负责将线程的任务映射到各个处理器上。

程序一般不会直接去使用内核线程，而是去使用内核线程的一种高级接口——轻量级进程(Light Weight Process, **LWP**)，轻量级进程就是通常意义上所讲的线程。每个轻量级进程都由一个内核线程支持，轻量级进程与内核线程之间1:1的关系称为一对一的线程模型，如下图。

![image-20200605144103973](Java%E4%B8%8E%E7%BA%BF%E7%A8%8B.assets/image-20200605144103973.png)

#### 轻量级进程的优势

每个轻量级进程都成为一个独立的调度单元，即使有一个轻量级进程在系统调用中阻塞了，也不会影响整个进程继续工作。

#### 轻量级进程的局限性

1. 由于是基于内核线程实现的，所以各种线程操作都**需要进行系统调用**。而系统调用的代价相对较高，需要在用户态(User Mode)和内核态(Kernel Mode)中来回切换；
2. 每个轻量级进程都需要有一个内核线程的支持，因此轻量级进程的**数量有限**；

### 2. 使用用户线程实现

- 广义上讲，一个线程只要不是内核线程，就可以认为是用户线程(User Thread, UT)；
- 狭义上讲，**用户线程指的是完全建立在用户空间的线程库上**，系统内核不能感知用户线程的存在；

![image-20200605145259041](Java%E4%B8%8E%E7%BA%BF%E7%A8%8B.assets/image-20200605145259041.png)

#### 用户线程的优势

**线程的操作完全在用户态中完成，不需要内核的帮助，不需要切换到内核态**，操作可以是非常快速且低消耗的，也可以支持规模更大的线程数量；

#### 用户线程的局限性

没有系统内核的支援，所有线程操作都需要用户程序自己处理，因此使用用户线程实现的程序一般都比较**复杂。现很少使用。**

### 3. 使用用户线程加轻量级进程混合实现

可以用内核提供的线程调度功能及处理器映射，并且用户线程的系统调用要通过轻量级线程来完成，大大降低了整个进程被完全阻塞的风险。

![image-20200605145318849](Java%E4%B8%8E%E7%BA%BF%E7%A8%8B.assets/image-20200605145318849.png)

### 4. Java线程的实现

JDK 1.2 之前基于用户线程实现，JDK 1.2 中线程模型替换为基于**操作系统原生线程模型**来实现。

Sun JDK中，由于Windows和Linux系统提供的线程模型就是一对一的，因此Windows版和Linux版都是使用一对一的线程模型实现的。



## Java线程调度

主要调度方式有两种：协同式线程调度(Cooperative Threads-Scheduling)和抢占式线程调度(Preemptive Threads-Scheduling)。

#### 协同式调度

协同式调度的多线程系统，线程的执行时间由线程本身来控制，线程把自己的工作执行完了之后，要主动通知系统切换到另一个线程上。

#### 抢占式调度

抢占式调度的多线程系统，**每个线程将由系统来分配执行时间，线程的切换不由线程本身来决定**。Java使用的线程调度方式就是抢占式调度。

Java语言一共设置了10个级别的线程优先级(```Thread.MIN_PRIORITY```到```Thread.MAX_PRIORITY```，即1-10)，在两个线程同时处于Ready状态时，优先级越高的线程越容易被系统选择执行。



## 状态转换

Java语言定义了6种线程状态，在任意一个时间点，一个线程只能有且只有其中的一个状态。如下所示。

1. 新建(New)
   - 创建后尚未启动的线程；
2. 运行(Runnable)
   - 包括操作系统线程状态中的Running和Ready；
3. 无限期等待(Waiting)
   - 处于这种状态的线程不会被分配CPU执行时间，它们要等待被其他线程显式地唤醒；
4. 限期等待(Timed Waiting)
   - 处于这种状态的线程也不会被分配CPU执行时间，不过无需等待被其他线程显式地唤醒，在一定时间之后它们会由系统自动唤醒。
5. 阻塞(Blocked)
   - 线程被阻塞。"阻塞状态"和"等待状态"的区别是**阻塞状态在等待获取一个排它锁**，而等待状态在等待唤醒动作发生或等待一段时间。
6. 结束(Terminated)
   - 已终止线程的线程状态，线程已经结束执行；

![image-20200605150634463](Java%E4%B8%8E%E7%BA%BF%E7%A8%8B.assets/image-20200605150634463.png)



## Reference

周志明.深入理解Java虚拟机：JVM高级特性与最佳实践（第2版）机械工业出版社