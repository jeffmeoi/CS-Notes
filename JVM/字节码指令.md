<!-- TOC -->

- [字节码指令](#字节码指令)
  - [加载和存储指令](#加载和存储指令)
  - [运算指令](#运算指令)
  - [类型转换指令](#类型转换指令)
  - [对象创建与访问指令](#对象创建与访问指令)
  - [操作数栈管理指令](#操作数栈管理指令)
  - [控制转移指令](#控制转移指令)
  - [方法调用和返回指令](#方法调用和返回指令)
  - [异常处理指令](#异常处理指令)
  - [同步指令](#同步指令)
  - [Reference](#reference)

<!-- /TOC -->

# 字节码指令

Java虚拟机的指令由**一个字节长度的、代表着某种特定操作含义的数字**（称为操作码，Opcode）以及跟随其后的**零至多个代表此操作所需参数**（称为操作数，Operands）而构成。

字节码指令集是一种具有鲜明特点、优劣势都很突出的指令集架构。

- 缺点
  1. 由于限制了Java虚拟机操作码的长度为一个字节，这意味着指令集的操作码总数不可能超过256条；
  2. 由于Class文件格式放弃了编译后代码的操作数长度对齐，这就意味着虚拟机处理那些超过一个字节数据的时候，需要以字节为单位读取再重组。

- 优点
  1. 省略很多填充和间隔符号，代码精简；

在Java虚拟机的指令集中，大多数的指令都包含了其操作所对应的数据类型信息。对于大部分与数据类型相关的字节码，他们的操作码助记符中都有特殊的字符来表明专门为哪种数据类型服务。

- Java虚拟机指令集与数据类型相关的字节码指令
  - ![image-20200522011655145](%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4.assets/image-20200522011655145.png)
  - 大部分对boolean、byte、short和char数据类型的操作都是使用相应的int类型作为运算类型
    - 大部分指令都没有支持整数类型byte、char和short，没有任何指令支持boolean类型，编译器会在编译期或运行期将byte和short类型的数据带符号扩展成相应的int类型数据，将boolean和char类型数据零扩展为相应的int类型。
    - 在处理boolean、byte、short和char类型的数组时，也会转换为使用对应的int类型的字节码指令来处理。

## 加载和存储指令

- 加载和存储指令用于将数据在栈帧的局部变量表和操作数栈之间来回传输；
- 包括以下指令
  - 将一个**局部变量**加载到**操作数栈**
    - *load
  - 将一个数值从**操作数栈**存储到**局部变量表**(store)
    - *store
  - 将一个常量加载到操作数栈(push)
    - ```*ipush```、```ldc*```、```*const_*```
  - 扩充局部变量表的访问索引的指令
    - wide

## 运算指令

- 运算或算术指令用于对两个操作数栈上的值进行某种特定运算，并把结果重新存入到**操作数栈顶**。
- 分为**对整型数据运算的指令**和**对浮点型数据运算的指令**
- 包括以下指令
  - 加法指令：iadd、ladd、fadd、dadd。
  - 减法指令：isub、lsub、fsub、dsub。
  - 乘法指令：imul、lmul、fmul、dmul。
  - 除法指令：idiv、ldiv、fdiv、ddiv。
  - 求余指令：irem、lrem、frem、drem。
  - 取反指令：ineg、lneg、fneg、dneg。
  - 位移指令：ishl、ishr、iushr、lshl、lshr、lushr。
  - 按位或指令：ior、lor。
  - 按位与指令：iand、land。
  - 按位异或指令：ixor、lxor。
  - 局部变量自增指令：iinc。
  - 比较指令：dcmpg、dcmpl、fcmpg、fcmpl、lcmp。
- **浮点运算**
  - Java虚拟机规范要求虚拟机实现在处理浮点数时必须**严格遵循IEEE 754规范中所规定的行为和限制**；
  - Java虚拟机要求在进行浮点数运算时，所有运算都必须**舍入到适当的精度**；
  - java虚拟机使用IEEE 754标准中的**向零舍入模式**；
  - Java虚拟机在处理浮点数运算时，**不会抛出任何运行时异常**。溢出用有符号的正无穷大表示，没有明确的数学定义的话会使用NaN值来表示。
  - Java虚拟机对long类型数值进行比较时，虚拟机采用带符号的比较方式，对浮点数值进行比较时，虚拟机会采用IEEE 754规范所定义的**无信号比较**方式；

## 类型转换指令

类型转换指令可以将两种不同的数值类型进行相互转换，这些转换操作一般用于实现用户代码中的**显式类型转换操作**，或者用来处理本节开篇所提到的字节码指令集中数据类型相关指令无法与数据类型一一对应的问题。

Java虚拟机直接支持（即转换时无需显式的转换指令）小范围类型向大范围类型的安全转换，处理窄化类型转换时必须显式地使用转换指令来完成，这些转换指令包括i2b、 i2c、 i2s、 l2i、 f2i、 f2l、 d2i、 d2l 和 d2f。

窄化类型转换可能会导致转换结果**产生不同的正负号、不同的数量级、数值的精度丢失。**

Java虚拟机明确规定数值类型的**窄化转换指令永远不可能导致虚拟机抛出运行时异常**。

## 对象创建与访问指令

Java虚拟机对**类实例和数组的创建与操作使用了不同的字节码指令**。

对象创建后，就可以通过对象访问指令获取对象实例或者数组实例中的字段或者数组元素

- 包括以下指令
  - **创建类实例**的指令：new。
  - **创建数组**的指令：newarray、anewarray、multianewarray。
  - 访问类字段（static字段，或者称为类变量）和实例字段（非static字段，或者称为实例变量）的指令：getfield、putfield、getstatic、putstatic。
  - 把一个数组元素加载到操作数栈的指令：baload、caload、saload、iaload、laload、faload、daload、aaload。
  - 将一个操作数栈的值存储到数组元素中的指令：bastore、castore、sastore、iastore、fastore、dastore、aastore。
  - 取数组长度的指令：arraylength。
  - 检查类实例类型的指令：instanceof、checkcast。

## 操作数栈管理指令

- 将操作数栈的栈顶一个或两个元素出栈：pop、pop2。
- 复制栈顶一个或两个数值并将复制值或双份的复制值重新压入栈顶：dup、dup2、dup_x1、dup2_x1、dup_x2、dup2_x2。
- 将栈最顶端的两个数值互换：swap。

## 控制转移指令

控制转移指令就是在有条件或无条件地修改PC寄存器的值。

- 包括以下指令
  - 条件分支：ifeq、iflt、ifle、ifne、ifgt、ifge、ifnull、ifnonnull、if_icmpeq、if_icmpne、if_icmplt、if_icmpgt、if_icmple、if_icmpge、if_acmpeq和if_acmpne。
  - 复合条件分支：tableswitch、lookupswitch。
  - 无条件分支：goto、goto_w、jsr、jsr_w、ret。

## 方法调用和返回指令

- invokevirtual指令用于调用对象的实例方法，根据对象的实际类型进行分派（**虚方法分派**），这也是Java语言中最常见的方法分派方式。
- invokeinterface指令用于调用接口方法，它会**在运行时搜索一个实现了这个接口方法的对象，找出适合的方法进行调用**。
- invokespecial指令用于调用一些需要特殊处理的实例方法，**包括实例初始化方法、私有方法和父类方法**。
- invokestatic指令用于**调用类方法（static方法）**。
- invokedynamic指令用于在运行时动态解析出调用点限定符所引用的方法，并执行该方法，前面4条调用指令的分派逻辑都固化在Java虚拟机内部，而invokedynamic指令的分派逻辑是**由用户所设定的引导方法决定的**。
- 方法返回指令是根据返回值的类型区分的，包括ireturn（当返回值是boolean、byte、char、short和int类型时使用）、lreturn、freturn、dreturn和areturn，return(返回值为void)

## 异常处理指令

throw语句都由athrow指令来实现。

Java虚拟机中采用异常表实现异常处理(catch语句)。

## 同步指令

Java虚拟机可以支持方法级的同步和方法内部一段指令序列的同步，这两种同步结构都是使用**管程（Monitor）**来支持的。

Java虚拟机通过检查方法常量池的方法表结构中的访问标志得知一个方法是否声明为同步方法。

如果是同步方法，执行前要求线程先持有管程，然后才能执行方法，在方法执行完成时释放管程。

当一个线程拥有管程时，其他线程不能再获得同一个管程。

管程相关指令：```monitorenter```和```monitorexit```



## Reference

周志明.深入理解Java虚拟机：JVM高级特性与最佳实践（第2版）机械工业出版社