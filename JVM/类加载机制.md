<!-- TOC -->

- [类加载机制](#类加载机制)
  - [类的生命周期](#类的生命周期)
  - [类加载的过程](#类加载的过程)
    - [加载(Loading)](#加载loading)
    - [验证(Verification)](#验证verification)
    - [准备(Preparation)](#准备preparation)
    - [解析(Resolution)](#解析resolution)
    - [初始化(Initialization)](#初始化initialization)
  - [类加载器](#类加载器)
    - [双亲委派模型](#双亲委派模型)
  - [Reference](#reference)

<!-- /TOC -->

# 类加载机制

## 类的生命周期

![image-20200522224722783](%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6.assets/image-20200522224722783.png)

- 加载、验证、准备、初始化和卸载这5个阶段的顺序是确定的，解析可能在初始化之后再开始。
- 验证、准备、解析三个阶段一起称为连接阶段；



## 类加载的过程

### 加载(Loading)

- 在加载阶段虚拟机需要完成的工作：
  1. 通过一个类的全限定名来获取定义此类的二进制字节流；(放在虚拟机外部由应用程序实现，即使用类加载器加载类)
  2. 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构；
  3. 在内存中生成一个代表这个类的```java.lang.Class```对象，作为方法区这个类的各种数据的访问入口；
- 加载阶段与连接阶段的部分内容是交叉进行的；

### 验证(Verification)

如果运行的全部代码都已经被反复使用和验证过，那么可以考虑使用```-Xverify:none```参数来关闭大部分的类验证措施，以缩短虚拟机类加载的时间。

1. 文件格式验证
   - 验证字节流是否符合Class文件格式的规范，能否被当前版本的虚拟机处理；
2. 元数据验证
   - 对字节码描述的信息进行语义分析；
3. 字节码验证
   - 对类的方法体进行校验分析，保证被校验类的方法在运行时不会做出危害虚拟机安全的事件，例如保证跳转指令不会跳转到方法体以外的字节码指令上；
4. 符号引用验证
   - 对类自身以外的信息进行匹配性校验；

### 准备(Preparation)

准备阶段是正式**为类变量分配内存并设置类变量初始值(通常情况下是零值)**的阶段，这些变量所使用的的内存都将在方法区中进行匹配。

### 解析(Resolution)

解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。

> **符号引用(Symbolic References)**：符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可；
>
> **直接引用(Direct References)：**直接引用可以是直接指向目标的指针、相对偏移量或是一个简洁定位到目标的句柄；

解析可以发生在类加载时，也可以发生在要被使用前。虚拟机可以对第一次解析的结果进行缓存，从而避免解析动作重复进行。

1. **类或接口的解析**
   1. 当前代码有类的符号引用，若该类不是一个数组类型，则把该类的全限定名传递给当前代码的类的类加载器加载类C；
   2. 当前代码有类的符号引用，若该类是一个数组类型且数组元素的类型为对象，则按照1去加载数组元素的类型，再由虚拟机生成一个代表此数组维度和元素的数组对象；
   3. 验证当前代码所处的类是否具备对该类的访问权限；
2. **字段解析**
   1. 当前代码引用了某类的字段，若该类包含了这个字段，则返回这个字段的直接引用；
   2. 否则，将按照继承关系从下往上递归搜索各个接口和它的父接口是否包含这个字段，如果包含，则返回这个字段的直接引用；
   3. 否则，将按照继承关系从下往上递归搜索其父类，如果包含，则返回这个字段的直接引用；
   4. 否则，查找失败，抛出```java.lang.NoSuchFieldError```异常。
   5. 验证是否具备对该字段的访问权限；

3. **类方法解析**

   1. 如果该类方法是接口方法，就直接抛出```IncompatibleClassChangeError```异常；
   2. 在该类方法对应的类中查找这个类方法，如果存在返回这个方法的直接引用；
   3. 否则，在该类方法对应的类的父类中递归查找该方法，如果存在则返回这个方法的直接引用；
   4. 否则，在该类方法对应的类的接口列表中地柜查找是否有该方法，如果存在则返回这个方法的直接引用；
   5. 否则，宣告方法查找失败，抛出```java.lang.NoSuchMethodError```异常；
   6. 验证是否具备对该类方法的访问权限；

4. **接口方法解析**

   1. 如果该接口方法是类方法，就直接抛出```IncompatibleClassChangeError```异常；
   2. 在该接口方法对应的接口中查找，如果有就返回这个方法的直接引用；
   3. 否则，在该接口方法对应的接口的父接口中递归查找（包括java.lang.Object类），如果有就返回这个方法的直接引用；
   4. 否则，宣告方法查找失败，抛出```java.lang.NoSuchMethodError```异常；

   > 接口中的所有方法默认都是public的，不存在访问权限的问题；

### 初始化(Initialization)

- 在**准备**阶段，变量已经赋过一次系统要求的初始值，在**初始化**阶段，是根据程序员通过程序制定的主观计划去初始化类和其他资源，即执行类构造器```<clinit>()```方法的过程。
- ```<clinit>()```方法是由编译期自动收集类中的所有类变量(static)的赋值动作和静态语句块(static{}块)中的语句合并产生的，编译器收集的顺序是由语句在源文件中出现的顺序所决定的。
- ```<clinit>()```方法不需要显式地调用父类构造器，虚拟机会保证在子类的```<clinit>```方法执行之前，父类的```<clinit>()```方法已经执行完毕。（即父类的静态语句块比子类的静态语句先）
- 执行接口的```<clinit>```方法不需要先执行父接口的```<clinit>```方法，而是需要使用到父接口中定义的变量时才会初始化；
- 虚拟机会保证一个类的```<clinit>```方法在多线程环境中被正确地加锁、同步；
- 同一个类加载器下，一个类型只会初始化一次；



## 类加载器

对于任意一个类，都需要由加载它的**类加载器和这个类**一同确立其在Java虚拟机中的**唯一性**。如果类加载器不同，类的```Class```对象的```equals()```方法、```isAssignableForm()```方法、```isInstance()```方法的返回结果，也包括使用```instanceof```关键字做对象的所属判定的情况都会不相等。

- 类加载器分类
  - 虚拟机角度
    - 启动类加载器(Bootstrap ClassLoader)，该类加载器由C++实现，是虚拟机的一部分；
    - 所有其他的类加载器，都由Java实现，独立于虚拟机；
  - 开发人员角度
    - 启动类加载器(Bootstrap ClassLoader)
      - 是虚拟机的一部分，负责加载```<JAVA_HOME>\lib```目录下或由```-Xbootclasspath```参数指定的路径中，能被虚拟机识别的类库；
    - 扩展类加载器(Extension ClassLoader)
      - 负责加载```<JAVA_HOME>\lib\ext```目录下或者```java.ext.dirs```系统变量所制定的路径中的所有类库；
    - 应用程序类加载器(Application ClassLoader)
      - 负责加载用户类路径(ClassPath)上所指定的类库，一般是程序中默认的类加载器；
    - 自定义类加载器(User ClassLoader)

### 双亲委派模型

![image-20200523120544627](%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6.assets/image-20200523120544627.png)

- 工作过程
  - 如果一个类加载器收到了类加载器的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，当父加载器无法返程这个加载请求时，子加载器才会尝试自己去加载。
- 优点
  - Java类随着它的类加载器一起具备了一种带有优先级的层次关系。例如，```java.lang.Object```由启动类加载器加载，无论哪个类加载器要加载这个类，最终都是委派给处于模型最顶层的类加载器进行加载。
- 实现(在```java.lang.ClassLoader```的```loadClass()```方法中)
  1. 先检查请求的类是否已经被加载过；
  2. 如果有父加载器，调用父加载器的```loadClass()```方法；
  3. 如果没有父加载器，默认使用启动类加载器(Bootstrap ClassLoader)作为父加载器；
  4. 如果父类加载失败再调用自己的```findClass()```方法进行加载；
- 破坏双亲委派模型
  - 重写```loadClass()```方法会破坏双亲委派模型；



## Reference

周志明.深入理解Java虚拟机：JVM高级特性与最佳实践（第2版）机械工业出版社