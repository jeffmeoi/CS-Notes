<!-- TOC -->

- [Java内存区域](#java内存区域)
  - [Java运行时数据区](#java运行时数据区)
    - [程序计数器(Program Counter Register)](#程序计数器program-counter-register)
    - [虚拟机栈(VM Stack)](#虚拟机栈vm-stack)
      - [栈帧的结构](#栈帧的结构)
        - [局部变量表](#局部变量表)
    - [本地方法栈(Native Method Stack)](#本地方法栈native-method-stack)
    - [Java堆（Heap, GC堆）](#java堆heap-gc堆)
    - [方法区(Non-Heap, 非堆)](#方法区non-heap-非堆)
      - [运行时常量池(Runtime Constant Pool)](#运行时常量池runtime-constant-pool)
    - [直接内存(Direct Memory)](#直接内存direct-memory)
  - [Java对象的创建](#java对象的创建)
    - [内存分配方式](#内存分配方式)
      - [解决方法](#解决方法)
    - [内存分配的并发问题](#内存分配的并发问题)
      - [解决方法](#解决方法-1)
    - [对象的内存布局](#对象的内存布局)
      - [对象头](#对象头)
      - [实例数据](#实例数据)
    - [对齐填充](#对齐填充)
  - [对象的访问定位](#对象的访问定位)
    - [句柄访问](#句柄访问)
    - [直接指针访问](#直接指针访问)
  - [Reference](#reference)

<!-- /TOC -->

# Java内存区域

## Java运行时数据区

![image-20200521174836248](Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F.assets/image-20200521174836248.png)

如上图，Java运行时数据区分为了程序计数器(Program Counter Register)、虚拟机栈(VM Stack)、本地方法栈(Native Method Stack)、方法区(Method Area)、堆(Heap)五个部分，在Java运行时数据区之外还有直接内存区。

其中，方法区、堆是所有线程共享的数据区；程序计数器、虚拟机栈、本地方法栈是线程隔离的数据区，即线程不共享的数据区。

### 程序计数器(Program Counter Register)

程序计数器（ Program Counter Register） 是一块较小的内存空间，它可以看作是当前线程所执行的字节码的行号指示器，是线程隔离的数据区，即每个线程都拥有一个程序计数器。

如果线程执行的是Java方法，则这个计数器记录的是正在执行的字节码指令的地址；如果线程执行的是Native方法，则这个计数器的值为空(undefined)。

### 虚拟机栈(VM Stack)

Java虚拟机栈描述的是Java方法执行的内存模型，同样是线程隔离的数据区。

每个Java方法在执行的时候都会创建一个栈帧(Stack Frame)，在栈帧内，存储局部变量表、操作数栈、动态链接、方法出口等信息。

#### 栈帧的结构

![image-20200521180106652](Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F.assets/image-20200521180106652.png)

##### 局部变量表

局部变量表存放了编译期可知的各种基本数据类型(boolean, byte, char, short, int, long, float, double)、对象引用(reference)和ReturnAddress类型。局部变量表所需的内存空间在编译期间完成分配，在运行期不会改变局部变量表的大小。

long, double占用2个局部变量空间(Slot)，其余的数据结构只占用1个。

引用类型没有明确规定大小，通常与计算机平台有关。JVM支持**指针压缩**，在64位平台使用32位的指针。

### 本地方法栈(Native Method Stack)

与虚拟机栈类似，不同的是，本地方法栈为Native方法服务，虚拟机栈为Java方法服务。

### Java堆（Heap, GC堆）

Java堆是垃圾收集器管理的主要区域，Java堆的唯一目的就是用于存放对象实例，Java虚拟机规范规定所有的对象实例以及数组都要在堆上分配。

Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。

Java堆中可能划分出多个线程私有的分配缓冲区(TLAB)以解决对象分配时的并发问题。

### 方法区(Non-Heap, 非堆)

方法区与是各个线程共享的内存区域，用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。

Java虚拟机规范对方法区的限制非常宽松，不需要连续的内存，可以选择固定大小或可扩展，可以选择不实现垃圾回收。

JDK 1.7，存放在方法区的字符串常量池移到了堆中。

JDK 1.8，方法区被取消，移到了直接内存的metaSpace。

#### 运行时常量池(Runtime Constant Pool)

运行时常量池是方法区的一部分。Class文件内有类的版本、字段、方法、常量池等，运行时常量池用来存放类加载后的Class文件内的常量池等数据。

运行时常量池具有动态性，不要求常量一定只有编译期才能产生，在运行期间也可能将新的常量放入池中。

### 直接内存(Direct Memory)

直接内存不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域。

直接内存不会受到Java堆的限制，但是会受到本机总内存(包括RAM及SWAP区或分页文件)大小以及处理器寻址空间的限制。



## Java对象的创建

1. 检查是否能在常量池中定位到类的符号引用
2. 检查这个符号引用代表的类是否已经被加载、解析和初始化
3. 为新生对象分配内存(**"碰撞指针"**和**"空闲链表"**)
4. 将分配的内存空间初始化为零值
5. 虚拟机设置新生对象的对象头
6. 执行```<init>```方法，按照程序员意愿进行初始化
7. 把新生对象的地址赋给引用

### 内存分配方式

在使用带整理过程的收集器时，系统采用指针碰撞，在使用标记擦除算法时，通常采用空闲列表。

#### 解决方法

1. 碰撞指针

   假设Java堆内存是绝对规整的，即用过的在一边，空闲的在另一边的情况下，可以用指针指向用过和空闲的内存空间的交界处，当分配内存空间时，移动指针即可。

2. 空闲链表

   假设Java堆内存不是规整的，那么需要维护一个空闲链表记录空闲内存块，在分配时找一块足够大的内存块划分给实例。

### 内存分配的并发问题

即使只是移动一下指针，同样会存在并发情况下的线程安全问题，可能存在把同一块空间分配给多个对象的情况。

#### 解决方法

1. 对分配内存空间的动作进行同步处理——虚拟机采用CAS配上失败重试的方式保证更新操作的原子性；
2. 在Java堆中划分出多个线程私有的分配缓冲区(TLAB)，使得内存分配的动作在不同空间之中进行。



### 对象的内存布局

在HotSpot虚拟机中，对象在内存中存储的布局可以分为3块区域：对象头(Header)、实例数据(Instance Data)和对其填充(Padding)。

#### 对象头

一部分用于存储对象自身的运行时数据，如哈希码(HashCode)、GC分代年龄、锁状态、线程持有的锁、偏向线程ID、偏向时间戳等，这部分数据的长度在32位和64位虚拟机中分别为32bit和64bit。

另一部分是类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。

#### 实例数据

对象真正存储的有效信息，即程序代码中各个类型的字段内容；

### 对齐填充

HotSpot VM的自动内存管理要求对象的起始地址必须是8字节的整数倍。



## 对象的访问定位

### 句柄访问

![image-20200521195205802](Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F.assets/image-20200521195205802.png)

Java堆会划出一块内存来作为句柄池，reference中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息。

- 优点
  - 在对象被移动（**垃圾收集**时移动对象是非常普遍的行为）时只会改变句柄中的实例数据指针，而reference本身不需要修改。
- 缺点
  - 访问需要先访问句柄池，再访问真实的地址，速度慢。

### 直接指针访问

![image-20200521200042714](Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F.assets/image-20200521200042714.png)

如果使用直接指针访问，那么Java堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，而reference中存储的直接就是对象地址。

- 优点
  - 直接访问真实的地址，速度快。
- 缺点
  - 在对象被移动时也要修改对象引用的值。




## Reference

周志明.深入理解Java虚拟机：JVM高级特性与最佳实践（第2版）机械工业出版社


