<!-- TOC -->

- [垃圾收集器与内存分配策略](#垃圾收集器与内存分配策略)
  - [如何确定对象存活](#如何确定对象存活)
    - [1. 引用计数法](#1-引用计数法)
    - [2. 根搜索算法](#2-根搜索算法)
  - [引用](#引用)
    - [强引用(Strong Reference)](#强引用strong-reference)
    - [软引用(Soft Reference)](#软引用soft-reference)
    - [弱引用(Weak Reference)](#弱引用weak-reference)
    - [虚引用(Phantom Reference)](#虚引用phantom-reference)
  - [如何确定是否回收](#如何确定是否回收)
  - [回收方法区](#回收方法区)
  - [垃圾收集算法](#垃圾收集算法)
    - [标记-清除算法](#标记-清除算法)
    - [复制算法](#复制算法)
    - [标记-整理算法](#标记-整理算法)
    - [分代收集算法](#分代收集算法)
    - [HotSpot VM的算法实现](#hotspot-vm的算法实现)
  - [垃圾收集器](#垃圾收集器)
    - [Serial收集器](#serial收集器)
    - [ParNew收集器](#parnew收集器)
    - [Parallel Scavenger收集器](#parallel-scavenger收集器)
    - [Serial Old收集器](#serial-old收集器)
    - [Parallel Old收集器](#parallel-old收集器)
    - [CMS收集器](#cms收集器)
    - [G1收集器](#g1收集器)
  - [内存分配与回收策略](#内存分配与回收策略)
    - [策略](#策略)
  - [Reference](#reference)

<!-- /TOC -->

# 垃圾收集器与内存分配策略

## 如何确定对象存活

### 1. 引用计数法

当有一个地方引用它时，计数器值就加1；当引用失效时，计数器就减1.计数器为0的对象就是不可能再被使用的。

- 存在问题
  - 很难解决循环引用的问题；

### 2. 根搜索算法

主流的商用程序语言(Java和C#)都是使用根搜索算法判定对象是否存活的。

- 基本思路
  - 通过一系列的名为"GC Roots"的对象作为起始点，从这些节点开始向下搜索，搜索走过的路径就是引用链，当一个对象到达GC Roots没有任何引用链相连时，则证明此对象是不可用的。
- 可作为GC Roots的对象包括：
  - 虚拟机栈中引用的对象；
  - 方法区中的类静态属性引用的对象；
  - 方法区中常量引用的对象；
  - 本地方法栈中JNI的引用的对象；



## 引用

### 强引用(Strong Reference)

- GC不会回收还存在强引用的对象

### 软引用(Soft Reference)

- 内存不够时，GC会回收掉只存在软引用的对象

### 弱引用(Weak Reference)

- 下一次GC发生时，GC会回收掉只存在弱引用的对象

### 虚引用(Phantom Reference)

- 对对象的生存时间没有影响，只是用来在回收掉时获取一个系统通知



## 如何确定是否回收

一个对象死亡，至少要经历两次标记过程。

1. 如果对象在进行根搜索后没有与GC Roots相连接的引用链，那会被第一次标记并进行一次筛选，筛选的条件是此对象是否有必要执行finalize()方法，当对象没有覆盖finalize()方法，或者finalize()方法已经被调用过时，虚拟机视为没有必要执行。
2. 如果有必要执行finalize()方法，那么对象会被放置在F-Queue队列中，稍后由一个低优先级的Finalizer线程执行。（执行指的是触发这个方法，虚拟机不会等待finalize()方法的结束，以防止等待时间过长导致GC崩溃）
3. 如果对象在finalize()方法中重新建立了引用，则该对象不会被回收，反正，则会在第二次标记时会被回收。



## 回收方法区

方法区主要回收两部分内容：废弃常量和无用的类，方法区的回收效率很低。

- 类被回收的条件
  - Java堆中不存在该类的实例；
  - 加载该类的类加载器被回收；
  - 该类的Class对象没有被访问；

- 大量使用反射、动态代理、CGLib等bytecode框架的场景都需要虚拟机具备卸载的功能，以保证永久代不会溢出。



## 垃圾收集算法

### 标记-清除算法

![image-20200521220503756](%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5.assets/image-20200521220503756.png)

- 两个阶段
  - 标记需要回收的对象；
  - 删除需要回收的对象；
- 优点
  - 简单；
- 缺点
  - 效率低；
  - 回收对象后会产生内存碎片；

### 复制算法

![image-20200521220512921](%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5.assets/image-20200521220512921.png)

- 将存活着的对象复制到另外一块内存上，然后把使用过的内存清空；
- 优点
  - 实现简单，运行高效；
- 缺点
  - 内存缩小为原来的一半；
  - 对象存活率较高时，要执行较多的复制；

- 减小内存损失的方法
  - 分配一块内存较大的Eden区和两块较小的Survivor区，每次使用一块Eden区和一块Survivor区，每次把Eden区和Survivor区中存活的对象复制到另一块Survivor区中；
  - Eden区和Survivor区默认为8:1的比例；
  - 当内存不够时，可以依赖老年代进行分配担保。

### 标记-整理算法

![image-20200521220523042](%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5.assets/image-20200521220523042.png)

- 让所有存活的对象向一端移动，然后清理掉边界以外的内存；

### 分代收集算法

- 根据对象的存活周期的不同将内存划分为几块。
- Java堆中分为新生代和老年代
  - 新生代中对象存活率低，选用复制算法；
  - 老年代中对象存活率高，选用标记-清除和标记-整理算法来进行回收；

### HotSpot VM的算法实现

- 准确式GC：准确式GC就是让JVM知道内存中某位置数据的类型是什么，这样JVM就可以快速的确定所有引用类型的位置。

- HotSpot采用```OopMap```实现准确式GC，在**类加载**完成时就计算出内存内的数据的类型，在**JIT编译过程**中，也会在特定位置记录下**栈和寄存器**的哪些位置是引用。
- 安全点
  - 通过OopMap，HotSpot可以很快完成GC Roots的查找，但是，如果在每一行代码都有可能发生GC，那么也就意味着得为每一行代码的指令都生成OopMap，这样将占用大量的空间。
  - HotSpot只在特定的位置记录了OopMap，这些位置就叫做安全点（**Safepoint**）
- 如何让所有线程都执行到安全点
  - 抢先式中断
    - 把所有线程中断，如果发现有线程中断的地方不在安全点上，则继续执行；
    - 现在几乎没有虚拟机采用抢先式中断；
  - 主动式中断
    - 当GC需要中断时，不直接对线程操作，而是设置一个标志，让各个线程在运行到安全点时主动轮询这个标志，发现中断标志为真就把自己挂起；
    - 实现思路，即设置一个地址为不可读，当到达安全点时，访问该地址，则会产生一个自陷异常信号；
- 安全区域
  - **安全区域**是指在一段代码片段之中，**引用关系不会发生变化**。当线程没有被分配CPU时间时，线程无法执行到安全点挂起，因此需要安全区域，当线程执行到安全区域时，标识自己已经进入了安全区域，当JVM发起GC时，不需要管标识为GC的线程。





## 垃圾收集器

### Serial收集器

- ![image-20200521223011602](%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5.assets/image-20200521223011602.png)
- Serial 是单线程收集器；
- Serial收集器用于新生代新生代，采用复制算法；

### ParNew收集器

- ![image-20200521223124212](%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5.assets/image-20200521223124212.png)
- ParNew 是多线程的收集器；
- ParNew 收集器用于新生代，采用复制算法；

### Parallel Scavenger收集器

- Parallel Scavenger收集器用于新生代；
- Parallel Scavenger收集器采用复制算法；
- 关注点是达到一个可控的吞吐量，可以高效率的利用CPU时间，适合后台运算；
- Parallel Scavenger收集器**本身有PS MarkSweep收集器进行老年代收集**，并非直接使用了Serial Old收集器，但实现非常接近；
- Parallel Scavenger不能使用CMS作为老年代；

### Serial Old收集器

![image-20200521223011602](%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5.assets/image-20200521223011602.png)

- Serial Old是单线程收集器；
- Serial Old收集器用于老年代，采用标记-整理算法；

### Parallel Old收集器

- Parallel Old收集器是Parallel Scavenger的老年代版本，使用多线程和“标记-整理”算法。
- Parallel Scavenger/Parallel Old收集器
  - ![image-20200521224119575](%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5.assets/image-20200521224119575.png)

### CMS收集器

- ![image-20200521224207825](%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5.assets/image-20200521224207825.png)
- CMS是老年代的收集器；
- 采用"标记-清除"算法
- 步骤
  - 初始标记
    - 标记GC Roots能直接关联到的对象；
  - 并发标记；
    - 执行根搜索算法，做可达性分析；
  - 重新标记；
    - 修正并发标记期间因用户程序继续运作导致标记产生变动的部分对象的标记记录；
  - 并发清除；
    - 清除被标记对象；
- 优点
  - 并发收集，低停顿；
- 缺点
  - CMS收集器对CPU资源非常敏感，在并发收集的过程中，由于占用了部分线程，总吞吐量会降低；
  - 采用"并发-清除"算法，会产生大量的内存碎片；
  - 无法处理浮动垃圾；

### G1收集器

- 特点
  - 并行与并发；
  - 分代收集；
  - 空间整合，不会产生内存空间碎片；
  - 可预测的停顿；
- 实现思路
  - G1收集器把Java堆划分成多个大小相等的独立区域(Region)，保留了新生代和老年代的概念，但新生代和老年代不再物理隔离，他们都是一部分Region的集合；
  - G1收集器跟踪各个Region里面垃圾堆积的价值大小，在后台维护一个优先队列，每次根据允许收集的时间，有限回收价值最大的Region，保证了G1收集器在有限的时间内可以获取尽可能高的回收效率。
- 步骤
  - 初始标记
    - 标记GC Roots能直接关联到的对象；
  - 并发标记
    - 执行根搜索算法，做可达性分析；
  - 最终标记
    - 修正并发标记期间因用户程序继续运作导致标记产生变动的部分对象的标记记录；
  - 筛选回收
    - 对Region的回收价值进行排序，根据用户所期望的GC停顿时间来制定回收计划；



## 内存分配与回收策略

- 新生代GC和老年代GC
  - 新生代GC(Minor GC)
    - 指发生在新生代的垃圾收集动作；
  - 老年代GC(Major GC/Full GC)
    - 指发生在老年代的GC，Major GC通常会伴随至少一次Minor GC，Major GC比Minor GC慢十倍以上；

### 策略

1. **对象优先在Eden区分配**

   - 当Eden区没有足够空间进行分配时，发起一次Minor GC；

2. **大对象直接进入老年代**

   - 所谓的大对象是指，需要大量连续内存空间的Java对象，最典型的大对象就是那种很长的字符串以及**数组**(数组也是对象)。

   - 原因
     - 避免在Eden区及两个Survivor区之间发生大量的内存复制；

3. **长期存活的对象将进入老年代**

   - 如果对象经过一次Minor GC，年龄就增加1岁，当对象的年龄增加到一定程度就会被晋升到老年代。

4. **动态年龄判定**

   - 如果Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，则年龄大于等于该年龄的对象就可以直接进入老年代；

5. **空间分配担保**

   - 发送Minor GC前，虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象总空间。
     - 如果成立，那么Minor GC可以确保是安全的；
     - 如果不成立，则虚拟机会检查是否允许担保失败；
       - 如果允许担保失败，则判断最大可用空间是否大于历次晋升的平均值；
         - 如果大于，则尝试进行Minor GC；
         - 如果小于，则进行Full GC；
       - 如果不允许担保失败，则进行一次Full GC；




## Reference

周志明.深入理解Java虚拟机：JVM高级特性与最佳实践（第2版）机械工业出版社


