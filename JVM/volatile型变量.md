<!-- TOC -->

- [volatile型变量](#volatile型变量)
  - [保证可见性](#保证可见性)
  - [Reference](#reference)

<!-- /TOC -->
# volatile型变量

- volatile是**轻量级的synchronized**，它在多处理器开发中保证了共享变量的“可见性”
  - 可见性：当一个线程修改一个共享变量时，另外一个线程能读到这个修改的值。
- 关键字volatile是Java虚拟机提供的最轻量级的同步机制；
- volatile具有两种特性
  - **保证**此变量对所有线程的**可见性**；
  - **禁止指令重排序优化**；
- volatile变量自身具有的特性
  - 可见性
    - 对一个volatile变量的写，（**任意线程**）总是能看到对这个volatile变量的最后的写入；
  - 原子性
    - 对任意单个volatile变量的**读/写操作**具有原子性(包括64位long/double的写)；

- 从内存语义的角度来说，volatile的写-读与锁的释放-获取有**相同的内存效果**：**volatile写和锁的释放**有相同的内存语义；**volatile读与锁的获取**有相同的内存语义。
  - volatile写会把线程对应的工作内存中修改过的值刷新到主内存中；
  - volatile读会把线程对应的工作内存置为无效；
  - 线程A写一个volatile变量，随后线程B读这个volatile变量，这个过程**实质上是线程A通过主内存向线程B发送消息**。

## 保证可见性

- 保证此变量对所有线程的可见性，即一条线程修改变量值后新值对于其他线程来说是可见的；
- volatile不能保证原子性，导致volatile变量的运算在并发下一样是不安全的；

- 使用volatile并发控制需要满足两条规则
  - 运算结果并不依赖变量的当前值，或者能够确保只有单一的线程修改变量的值；
  - 变量不需要与前面的状态变量共同参与不变约束；

## volatile的实现原则

- IA-32架构中，Lock前缀的指令会引起处理器缓存写回到内存。Lock前缀指令导致在执行指令期间，声言处理器的Lock#信号。
  - 早期的处理器Lock#信号锁总线；最近的处理器中，Lock信号一般锁缓存。
- 一个处理器的缓存写回到内存会导致其他处理器的缓存无效。IA-32和Intel64位处理器使用MESI控制协议去维护内部缓存和其他处理器缓存的一致性。

## volatile内存语义的实现

- JMM针对编译器制定的volatile重排序规则表
  - ![image-20210209114206856](volatile%E5%9E%8B%E5%8F%98%E9%87%8F.assets/image-20210209114206856.png)
  - 为了实现volatile的内存语义，编译器在生成字节码时，会在指令序列中插入内存屏障来禁止特定类型的处理器重排序。
    - JMM采取保守策略
      - 在每个volatile写操作的前面插入一个StoreStore屏障。
      - 在每个volatile写操作的后面插入一个StoreLoad屏障。 
      - 在每个volatile读操作的后面插入一个LoadLoad屏障。 
      - 在每个volatile读操作的后面插入一个LoadStore屏障。
- 在旧的内存模型中，volatile的写-读没有锁的释放-获取所具有的内存语义。为了提供一种**比锁更轻量级的线程之间通信的机制**，JSR-133专家组决定增强volatile的内存语义：严格限制编译器和处理器对volatile变量与普通变量的重排序，**确保volatile的写-读和锁的释放-获取具有相同的内存语义**。
- 由于**volatile仅仅保证对单个volatile变量的读/写具有原子性**，而锁的互斥执行的特性可以确保对整个临界区代码的执行具有原子性。**在功能上，锁比volatile更强大；在可伸缩性和执行性能上，volatile更有优势。**

## Reference

周志明.深入理解Java虚拟机：JVM高级特性与最佳实践（第2版）机械工业出版社

方腾飞; 魏鹏; 程晓明. Java并发编程的艺术 (Java核心技术系列). 机械工业出版社