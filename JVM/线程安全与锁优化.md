<!-- TOC -->

- [线程安全与锁优化](#线程安全与锁优化)
  - [Java语言中的线程安全](#java语言中的线程安全)
    - [1. 不可变](#1-不可变)
    - [2. 绝对线程安全](#2-绝对线程安全)
    - [3. 相对线程安全](#3-相对线程安全)
    - [4. 线程兼容](#4-线程兼容)
    - [5. 线程对立](#5-线程对立)
  - [线程安全的实现方法](#线程安全的实现方法)
    - [1. 互斥同步](#1-互斥同步)
      - [synchronized同步块](#synchronized同步块)
      - [ReentrantLock可重入锁](#reentrantlock可重入锁)
      - [synchronized和ReentrantLock对比](#synchronized和reentrantlock对比)
    - [2. 非阻塞同步](#2-非阻塞同步)
      - [CAS](#cas)
    - [3. 无同步方案](#3-无同步方案)
      - [可重入代码(Reentrant Code)](#可重入代码reentrant-code)
      - [线程本地存储(Thread Local Storage)](#线程本地存储thread-local-storage)
  - [锁优化](#锁优化)
    - [自旋锁与自适应自选](#自旋锁与自适应自选)
    - [锁消除](#锁消除)
    - [锁粗化](#锁粗化)
    - [轻量级锁](#轻量级锁)
      - [实现原理](#实现原理)
        - [加锁过程](#加锁过程)
        - [解锁过程](#解锁过程)
    - [偏向锁](#偏向锁)
  - [Reference](#reference)

<!-- /TOC -->

# 线程安全与锁优化

- Java的并发机制依赖于JVM的实现和CPU的指令

- 线程安全
  - 当多个线程访问一个对象时，**如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步，或者在调用方进行任何其他的协调操作，调用这个对象的行为都可以获得正确的结果**，那这个对象是线程安全的。

## Java语言中的线程安全

按照线程安全的“安全程度”由强至弱来排序，可以将Java语言中各种操作共享的数据分为以下五类：不可变、绝对线程安全、相对线程安全、线程兼容和线程对立；

### 1. 不可变

不可变（Immutable）的对象一定是线程安全的，无论是对象的方法实现还是方法的调用者，都不需要再采取任何的线程安全保障措施。

Java语言中，如果共享数据是一个基本数据类型，那么只要在定义时使用final关键字修饰它就可以保证它是不可变的。如果共享数据是一个对象，那就需要保证对象的行为不会对其状态产生任何影响才行，例如，String类的replace等方法不会影响它原来的值。

### 2. 绝对线程安全

绝对线程安全要求不管运行时环境如何，调用者都不需要任何额外的同步措施。

### 3. 相对线程安全

相对线程安全需要保证对这个对象单独的操作是线程安全的，在调用时不需要做额外的保障措施。

Java API中标注自己是线程安全的类，大多数是相对线程安全的，例如，Vector、HashTable、```Collections.synchronizedCollection()```方法包装的集合等。

### 4. 线程兼容

线程兼容是指对象本身并不是线程安全的，但是可以通过在调用端正确地使用同步手段来保证对象在并发环境中可以安全地使用，例如，ArrayList、HashMap等。

### 5. 线程对立

线程对立是指无论调用端是否采用了同步措施，都无法在多线程环境中并发使用的代码，应尽量避免。例如Thread类的suspend()和resume()方法，已经被JDK声明废弃了。



## 线程安全的实现方法

1. 互斥同步
   1. synchronized
   2. ReentrantLock可重入锁
2. 非阻塞同步
3. 无同步方案

### 1. 互斥同步

互斥是方法，同步是目的。

- 同步是指在多个线程并发访问共享数据时，保证共享数据在同一个时刻只被一个（或者是一些，使用信号量的时候）线程使用。

- 互斥是实现同步的一种手段，**临界区（Critical Section）、互斥量（Mutex）和信号量（Semaphore）**都是主要的互斥实现方式。

互斥同步属于一种悲观的并发策略，总是认为只要不去做正确的同步措施，那就肯定会出现问题，因此无论共享数据是否出现竞争，都要进行加锁。

**在Java中，最基本的互斥同步手段就是synchronized关键字**，synchronized关键字经过编译之后，会在同步块的前后分别形成monitorenter和monitorexit这两个字节码指令，**这两个字节码都需要一个reference类型的参数来指明要锁定和解锁的对象。**

#### synchronized同步块

- 特点
  - synchronized同步块对同一条线程来说是**可重入的**，不会出现把自己锁死的问题；
  - synchronized同步块在已进入的线程执行完之前，会**阻塞后面其他线程的进入**；
  - synchronized是Java语言中一个**重量级的操作**；
- 实现
  - JVM基于进入和退出Monitor对象来实现方法同步和代码块同步。

    - 代码块同步是使用``monitorenter``和`monitorexit`指令实现的；
    - 方法同步是使用另一种方法实现的，细节在JVM规范中并没有详细说明，但是方法的同步同样可以使用者两个指令来实现；
- synchronized用的锁时存在**Java对象头**里的。如果对象是**数组**类型，则虚拟机用**3个字宽(Word)存储对象头**，如果对象是**非数组**类型，则用**2字宽存储对象头**。

#### ReentrantLock可重入锁

- ReentrantLock在java.util.concurrent(J.U.C)包中；
- volatile变量是ReentrantLock内存语义实现的关键；
  - 编译器不会对volatile读与volatile读后面的任意内存操作重排序；编译器不会对volatile写与volatile写前面的任意内存操作重排序。组合这两个条件，意味着为了同时实现volatile读和volatile写的内存语义，编译器不能对CAS与CAS前面和后面的任意内存操作重排序。
  - Java的CAS同时具有volatile读和volatile写的内存语义；

#### synchronized和ReentrantLock对比

- synchronized是原生语法层面的互斥锁，由JVM实现；ReentrantLock是API层面的互斥锁，由JDK实现；
- 在JDK 1.6前，synchronized性能不如ReentrantLock；在JDK 1.6后，synchronized性能和ReentrantLock完全持平，由于synchronized是Java原始语法层面的，因此优先考虑synchronized；

- ReentrantLock相比synchronized增加的高级功能；
  - 等待可中断；
    - 等待可中断是指持有锁的线程长期不释放锁的时候，正在等待的线程可以选择放弃等待；
  - 可实现公平锁；
    - 公平锁是指多个线程在等待同一个锁时，必须按照申请锁的时间顺序来依次获得锁；
  - 锁可以绑定多个条件；
    - 锁绑定多个条件是指一个ReentrantLock对象可以同时绑定多个Condition对象；

### 2. 非阻塞同步

**非阻塞同步是基于冲突检测的乐观并发策略**，通俗地说，就是先进行操作，如果没有其他线程争用共享数据，那操作就成功了；如果共享数据有争用，产生了冲突，那就再采取其他的补偿措施（最常见的补偿措施就是不断地重试，直到成功为止）。

乐观并发策略需要操作和冲突检测这两个步骤具备原子性，为避免使用互斥同步，需要由硬件指令集提供支持，例如```CompareAndSwap(即CAS)```。

#### CAS

- CAS需要3个操作数，分别是内存位置，旧的预期值和新值。
- JDK 1.5 之后，```sun.misc.Unsafe```类里面提供了```compareAndSwapInt()```和```compareAndSwapLong()```等几个方法。
- Unsafe类只能由**启动类加载器(Bootstrap ClassLoader)**加载的Class才可以访问，因此如果不采用反射，只能间接使用它。例如，J.U.C包里面的整数原子类，其中的```compareAndSet()```和```getAndIncrement()```等方法采用了Unsafe类的CAS操作。
- 由于CAS操作是通过判断变量值来判断状态的变化，CAS操作存在"ABA"问题，即假设值起初为A，被改为B后，再改为A，CAS会认为该值没有发生过改变。
- CAS实现原子操作的三大问题

  - ABA问题
    - 解决思路：使用版本号
  - 循环时间长开销大
  - 只能保证一个共享变量的原子操作
    - JDK提供了`AtomicReference`类来保证引用对象之间的原子性，可以把多个变量放在一个对象里来进行CAS操作

### 3. 无同步方案

- 如果一个方法本来就不涉及共享数据，那它自然就无须任何同步措施去保证正确性。

#### 可重入代码(Reentrant Code)

- 这种代码也叫做纯代码(Pure Code)，可以在代码执行的任何时刻中断它，转而去执行另外一段代码(包括递归调用本身)，而在控制权返回后，原来的程序不会出现任何错误。
- 可重入代码不依赖公用的资源，例如，方法内只使用局部变量；

#### 线程本地存储(Thread Local Storage)

- 把共享数据的可见范围限制在同一个线程之内，无须同步也能保证线程之间不出现数据争用的问题。即，```ThreadLocal```类。



## 锁优化

### 自旋锁与自适应自旋

- 互斥同步对性能最大的影响是阻塞的实现，挂起线程和恢复线程的操作都需要转入内核态中完成。自旋锁的实现就是采用忙循环(自选)代替阻塞。

- JDK1.6以后，自旋锁改为**默认开启**了。
- **如果锁被占用的时间很短，自旋等待的效果就会非常好**，反之，如果锁被占用的时间很长，那么自旋的线程只会白白消耗处理器资源，而不会做任何有用的工作，反而会带来性能上的浪费。
- 自旋等待的时间必须要有一定的限度，**如果自旋超过了限定的次数仍然没有成功获得锁，就应当使用传统的方式去挂起线程了。**

### 锁消除

- 锁消除是指虚拟机即时编译器在运行时，对一些代码上要求同步，但是被检测到不可能存在共享数据竞争的锁被进行消除。

### 锁粗化

- **原则上，编写代码时总是推荐将同步块的作用返回限制得尽量小。**如果一系列的连续操作都对同一个对象反复的加锁解锁，甚至加锁操作是出现在循环体中的，那即使没有线程竞争，**频繁地进行互斥同步操作也会导致不必要的性能损耗，因此需要锁粗化**。

### 轻量级锁

轻量级锁不是用来替代重量级锁的，而是在没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗。

轻量级锁能提升程序同步性能的**依据**是“**对于绝大部分的锁，在整个同步周期内都是不存在竞争的**”，这是一个经验数据。如果没有竞争，轻量级锁使用CAS操作避免了使用互斥量的开销，但如果存在锁竞争，除了互斥量的开销外，还额外发生了CAS操作，**因此在有竞争的情况下，轻量级锁会比传统的重量级锁更慢。**

#### 实现原理

HotSpot虚拟机的对象头(Object Header)分为两部分信息，一部分用于存储对象自身的运行时数据，另一部分用于存储指向方法区对象类型数据的指针，如果是数组的话还会有一个额外的部分用于存储数组长度。

##### 对象头

对象头信息是与对象自身定义的数据无关的额外存储成本，考虑到虚拟机的空间效率，Mark Word被设计成一个非固定的数据结构以便在极小的空间内存储尽量多的信息，它会根据对象的状态复用自己的存储空间。

![image-20210207134604108](%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E4%B8%8E%E9%94%81%E4%BC%98%E5%8C%96.assets/image-20210207134604108.png)

##### Mark Word

- 无锁状态
  - ![image-20210207134731939](%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E4%B8%8E%E9%94%81%E4%BC%98%E5%8C%96.assets/image-20210207134731939.png)
- Mark Word的状态变化
  - ![image-20210207134746945](%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E4%B8%8E%E9%94%81%E4%BC%98%E5%8C%96.assets/image-20210207134746945.png)

- Mark Word标志位的变化
  - ![image-20200605194827118](%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E4%B8%8E%E9%94%81%E4%BC%98%E5%8C%96.assets/image-20200605194827118.png)

##### 加锁过程

在代码进入同步块的时候，如果此同步对象没有被锁定(锁标志位为01)，虚拟机首先将在当前线程的栈帧中建立一个名为锁记录(Lock Record)的空间，用于存储锁对象目前的Mark Word的拷贝，然后虚拟机将使用CAS操作尝试将对象的Mark Word更新为指向Lock Record的指针，如图所示。

- 如果CAS操作执行成功，则该线程就拥有了该对象的锁；
- 如果CAS操作执行失败，则判断对象的Mark Word是否指向当前线程的栈帧。如果是，则说明该对象已经拥有了这个对象的锁，可重入；否则，膨胀为重量级锁。

![image-20200605195121162](%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E4%B8%8E%E9%94%81%E4%BC%98%E5%8C%96.assets/image-20200605195121162.png)

![image-20200605195128568](%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E4%B8%8E%E9%94%81%E4%BC%98%E5%8C%96.assets/image-20200605195128568.png)

##### 解锁过程

通过CAS操作把对象当前的Mark Word和线程中复制的Displaced Mark Word替换回来。如果失败，则说明有其他线程尝试过获取该锁，那就要在释放锁的同时唤醒尝试获取该锁被挂起的线程。

![image-20210207140238153](%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E4%B8%8E%E9%94%81%E4%BC%98%E5%8C%96.assets/image-20210207140238153.png)

### 偏向锁

- 偏向锁使用了一种**等到竞争出现才释放锁的机制**，所以当其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁。

- 目的是**消除数据在无竞争情况下的同步原语，进一步提高程序的运行性能**。

- 轻量级锁是在无竞争的情况下使用CAS操作去消除同步使用的互斥量，那**偏向锁就是在无竞争的情况下把整个同步都消除掉，连CAS操作都不做了**。

偏向锁会偏向于第一个获得它的线程，JDK 1.6 后默认启用偏向锁。

![image-20200605194827118](%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E4%B8%8E%E9%94%81%E4%BC%98%E5%8C%96.assets/image-20200605194827118.png)

当锁对象第一次被线程获取时，虚拟机会把对象头的标志位设为"01"，同时使用CAS操作把获取到的所得线程ID记录在对象的Mark Word中，**如果CAS操作成功，持有偏向锁的线程以后每次进入这个锁相关的同步块时，虚拟机都可以不再进行任何同步操作。**

当有另一个线程尝试获取这个锁时，偏向模式就宣告结束。撤销偏向(Revoke Bias)后恢复到未锁定或轻量级锁定状态，后续同步操作与轻量级锁一致，如下图所示。

![image-20200605200610206](%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E4%B8%8E%E9%94%81%E4%BC%98%E5%8C%96.assets/image-20200605200610206.png)

**偏向锁可以提高带有同步但无竞争的程序性能。**它同样是一个带有效益权衡（Trade Off）性质的优化，也就是说，它并不一定总是对程序运行有利，如果程序中大多数的锁总是被多个不同的线程访问，那偏向模式就是多余的。

![image-20210207135846839](%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E4%B8%8E%E9%94%81%E4%BC%98%E5%8C%96.assets/image-20210207135846839.png)

### 锁的优缺点对比

![image-20210207140503005](%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E4%B8%8E%E9%94%81%E4%BC%98%E5%8C%96.assets/image-20210207140503005.png)

### 原子操作

- 不可中断的一个或一系列操作
- **处理器**提供两个极致来保证复杂内存操作的原子性
  - **总线锁定**
    - 在一个处理器使用总线时，阻塞其他处理器的请求
    - 总线锁把CPU和内存之间的通信锁住了，在锁定期间，其他处理器不能操作其他内存地址的数据，总线锁定的开销比较大。
  - **缓存锁定**
    - 锁定共享内存的缓存行
    - 两种情况下处理器不会使用缓存锁定
      - 操作的数据不能被缓存在处理器内部，或操作的数据跨多个缓存行时，则处理器会调用总线锁定；
      - 有些处理器不支持缓存锁定；

### Java中如何实现原子操作

- 锁

- 循环CAS

  - eg.

    ```java
    for(::){
    // 自增
        int i = atomicI.get();
        boolean suc = atomicI.compareAndSet(i, ++i);
    	if(suc)	break;
    }
    ```

## Reference

周志明.深入理解Java虚拟机：JVM高级特性与最佳实践（第2版）机械工业出版社

方腾飞; 魏鹏; 程晓明. Java并发编程的艺术 (Java核心技术系列). 机械工业出版社