<!-- TOC -->

- [虚拟机字节码执行引擎](#虚拟机字节码执行引擎)
  - [运行时栈帧结构](#运行时栈帧结构)
    - [栈帧(Stack Frame)](#栈帧stack-frame)
      - [局部变量表(Local Variable Table)](#局部变量表local-variable-table)
      - [操作数栈(Operand Stack)](#操作数栈operand-stack)
      - [动态链接(Dynamic Linking)](#动态链接dynamic-linking)
      - [返回地址(Return Address)](#返回地址return-address)
      - [附加信息](#附加信息)
    - [方法调用](#方法调用)
        - [解析](#解析)
        - [分派](#分派)

<!-- /TOC -->
# 虚拟机字节码执行引擎

## 运行时栈帧结构

### 栈帧(Stack Frame)

- 栈帧是用于支持虚拟机进行方法调用和方法执行的数据结构，是虚拟机运行时数据区中的虚拟机栈(Virtual Machine Stack)的栈元素。

- 栈帧存储了方法的局部变量表、操作数栈、动态链接和方法返回地址等信息。

- 位于栈顶的栈帧才是有效的，称为当前栈帧(Current Stack Frame)，与当前栈帧相关联的方法称为当前方法(Current Method)；

![image-20200523165445992](%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AD%97%E8%8A%82%E7%A0%81%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E.assets/image-20200523165445992.png)

#### 局部变量表(Local Variable Table)

- 局部变量表是一组变量值存储空间，用于存放方法参数和方法内部定义的局部变量。
- 局部变量表的最大容量由Class文件中方法的Code属性中的数据项决定；
- 局部变量表的容量**以变量槽(Variable Slot)为最小单位**，虚拟机规范中规定每个Slot都应该能存放一个boolean、byte、char、short、int、float、reference或returnAddress类型的数据，一般是32字节；
- 对于64位的数据类型，虚拟机会以高位对其的方式为其分配两个连续的Slot空间。对于使用多个Slot空间的数据类型，虚拟机不允许单独访问一个Slot空间；
- 虚拟机通过索引定位的方式使用局部变量表；
- 虚拟机使用**局部变量表**完成参数值到**参数**变量列表的传递过程。如果执行的是实例方法(非static的方法)，那局部变量表中第0位索引的Slot默认是用于传递方法所属对象实例的引用，即**this**；
-  局部变量表中的Slot是可以重用的；

#### 操作数栈(Operand Stack)

- 操作数栈的最大容量由Class文件中方法的Code属性中的数据项决定；

#### 动态链接(Dynamic Linking)

- 存有一个指向运行时常量池中该栈帧所属方法的引用，持有这个而引用是为了支持方法调用过程中的动态连接。

#### 返回地址(Return Address)

- 一般来说，方法正常退出时，调用者的PC计数器的值可以作为返回地址，栈帧中很可能会保存这个计数器值；方法异常退出时，返回地址由异常处理器决定，栈帧中通常不会保存这部分信息。

- 方法退出的过程实际上就等同于把当前栈帧出栈。

#### 附加信息

- 取决于具体的虚拟机实现；

### 方法调用

- 方法调用并不等同于方法执行，方法调用阶段的唯一任务就是确定被调用方法的版本，暂时还不涉及方法内部的具体运行过程；
- 方法调用是程序运行时最普遍、最频繁的操作；

##### 解析

- 所有方法调用的目标方法在Class文件里都是一个常量池中的符号引用；
- 在类加载的解析阶段，会将其中一部分符号引用转化为直接引用
  - 前提：调用目标在编译期进行编译时就必须确定下来
  - 包括**静态方法**、**私有方法**、**实例构造器**、**父类方法**，在类加载阶段的解析阶段就会把符号引用解析为该方法的直接引用；

##### 分派

1. 静态分派
   - 在编译阶段，Javac编译期会根据参数的静态类型决定使用哪个**重载**版本；
   - 所有**依赖静态类型**来定位方法执行版本的分派动作称为静态分派；
   - 重载会做自动类型转换，例如char类型的参数会按顺序提升，如——char->int->long->float->double->对象->对象的接口->父类->父类的接口->...
   - 方法重载的本质；
2. 动态分派
   - 在运行时根据实际类型确定方法执行版本的分派过程称为动态分派；
   - 方法重写的本质；
3. 单分派与多分派
   - 静态分派过程中，依据静态类型和方法参数两个宗量选择目标方法，所以是静态多分派;
   - 动态分派过程中，只依据方法的接收者的实际类型一个宗量选择目标方法，所以是动态单分派；
   - Java是一门静态多分派、动态单分派的语言；
4. 虚拟机动态分派的实现
   - 动态分派是非常频繁的动作，而且动态分派的方法版本选择过程需要运行时在类的方法元数据中搜索合适的目标方法；
   - 稳定优化手段——在类的方法区中建立一个虚方法表
     - ![image-20200604104629836](%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AD%97%E8%8A%82%E7%A0%81%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E.assets/image-20200604104629836.png)
     - 虚方法表中存放着各个方法的实际入口地址。如果某个方法在子类中没有被重写，那子类的虚方法表里面的地址入口指向父类的实现入口；如果某个方法在子类中被重写，那子类的虚方法表里面的地址入口被替换为指向子类实现版本的入口地址；
     - 具有相同签名的方法在父类、子类的虚方法表中应当具有一样的索引序号；





